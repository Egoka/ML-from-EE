def compression():
    pass
    # Входные данные представляют из себя цветные изображения типа JPEG, размера 48х48 пикселей.


def splitIntoThreeChannels():
    pass
    # Каждое изображение разбивается на 3 канала: красный, синий, зеленый.
    # Таким образом получается 3 изображения размера 48х48 пикселей.
    # Входные данные каждого конкретного значения пикселя нормализуются в диапазон от 0 до 1.


def strideLayer():
    pass
    # Сверхточный слой представляет из себя набор карт, у каждой карты есть синаптическое ядро.
    # Количество карт определяется требованиями к задаче, в большинстве случаев предлагается брать соотношение один к двум.
    # Размер у всех карт сверхточного слоя – одинаковы и вычисляются по формуле
    #        w = mW - kW + 1        h = mH - kH + 1
    # mW - ширина предыдущей карты
    # mH - высота предыдущей карты
    # kW - ширина ядра
    # kH - высота ядра
    # Размер ядра обычно берут в пределах от 3х3 до 7х7
    # Изначально значения каждой карты сверхточного слоя равны 0.
    # Значения весов ядер задаются случайным образом в области от -0.5 до 0.5.
    #################
    # Ядро скользит по предыдущей карте и производит операцию свертка, формула:
    #
    # rolledUpLayer[w,h]=sum(picture[pictureW-nucleusW,pictureH-nucleusH]*nucleus[nucleusW,nucleusH])
    #
    #################
    # В зависимости от метода обработки краев исходной матрицы результат может быть
    # меньше исходного изображения (valid), такого же размера (same) или большего размера (full)


def subsampleLayer():
    pass
    # Под выборочный слой также, как и сверхточный имеет карты, но их количество совпадает с предыдущим (сверхточным) слоем.
    # Цель слоя – уменьшение размерности карт предыдущего слоя.
    # В процессе сканирования ядром под выборочного слоя карты предыдущего слоя,
    # сканирующее ядро не пересекается в отличие от сверхточного слоя.
    # Обычно, каждая карта имеет ядро размером 2x2, что позволяет уменьшить предыдущие карты сверхточного слоя в 2 раза.
    # Вся карта признаков разделяется на ячейки 2х2 элемента, из которых выбираются максимальные по значению.
    # В под выборочном слое применяется функция активации MaxPooling – выбор максимального.
    #
    # compactLayer[w,h]=localMax(rolledUpLayer)


def neuralNetwork():
    pass
    # Цель слоя – классификация, моделирует сложную нелинейную функцию


def activationFunction():
    pass
    # В качестве функции активации в скрытых и выходном слоях применяется гиперболический тангенс


def backStrideLayer():
    pass
    # Вычисление δ происходит путем обратной свертки.
    # Для понимания обратно свертки, скользящее окно по карте признаков можно интерпретировать,
    # как обычный скрытый слой со связями между нейронами, но главное отличие — это то, что эти связи разделяемы,
    # то есть одна связь с конкретным значением веса может быть у нескольких пар нейронов, а не только одной.
    # Вычисление дельт происходит таким же образом, как и в скрытом слое полно связной сети.


def backSubsampleLayer():
    pass
    # Метод заключающийся в повороте ядра на 180 градусов и скользящем процессе сканирования сверхточной карты дельт
    # с измененными краевыми эффектами. Необходимо взять ядро сверхточной карты (следующего за под выборочным слоем)
    # повернуть его на 180 градусов и сделать обычную свертку по вычисленным ранее дельтам сверхточной карты,
    # но так чтобы окно сканирования выходило за пределы карты.

